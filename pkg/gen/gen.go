package gen

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/dolmen-go/codegen"
	"github.com/sirupsen/logrus"
)

const yearsFile = "./pkg/years/years.go"

var validPuzzleFile = regexp.MustCompile(`^day[0-3][0-9]$`)

func puzzlePath(year int) string {
	return fmt.Sprintf("./pkg/year%d", year)
}

func puzzleFileName(year, day int) string {
	path := puzzlePath(year)
	return fmt.Sprintf("%s/day%s.go", path, FormatDay(day))
}

func puzzleInputPath(year int) string {
	return fmt.Sprintf("./pkg/year%d/inputs", year)
}

func puzzleInputFileName(year, day int) string {
	path := puzzleInputPath(year)
	return fmt.Sprintf("%s/%d.txt", path, day)
}

// Generate yearXXXX directory if not exists
func newYearPkgDirectory(year int) {
	path := puzzlePath(year)
	if err := createDirectory(path); err != nil {
		logrus.Fatal(err)
	}
}

func createDirectory(path string) error {
	if _, err := os.Stat(path); err == nil || !errors.Is(err, os.ErrNotExist) {
		logrus.Infof("Directory already exists: %s", path)
		return nil
	}

	err := os.Mkdir(path, os.ModePerm)
	if err != nil {
		return err
	}

	logrus.Infof("Created directory: %s", path)
	return nil
}

// Generate inputs directory if not exists, generate empty input file
func NewInputFile(year, day int) {
	path := puzzleInputPath(year)
	inputFileName := puzzleInputFileName(year, day)

	if _, err := os.Stat(inputFileName); err != nil && err == os.ErrNotExist {
		logrus.Infof("Input file already exists: %s", inputFileName)
		return
	}

	err := createDirectory(path)
	if err != nil {
		logrus.Fatal(err)
	}

	f, err := os.Create(inputFileName)
	if err != nil {
		logrus.Fatal(err)
	}
	defer f.Close()

	logrus.Infof("Generated empty input file: %s", inputFileName)

	webInput := string(WebInput(year, day))

	if webInput != "" {
		logrus.Infof("Fetched data from AOC website for file: %s", inputFileName)
		f.WriteString(webInput)
	}
}

const puzzleTemplate = `// Code generated by aocgen; DO NOT EDIT.
	package year{{.Year}}

	type Day{{.Day}} struct{}
	
	func (p Day{{.Day}}) PartA(lines []string) any {
		return "implement_me"
	}
	
	func (p Day{{.Day}}) PartB(lines []string) any {
		return "implement_me"
	}
	
`

func NewPuzzleFile(year, day int) {
	fileName := puzzleFileName(year, day)
	if _, err := os.Stat(fileName); err == nil || !errors.Is(err, os.ErrNotExist) {
		logrus.Infof("Puzzle file already exists: %s", fileName)
		return
	}

	tmpl := codegen.MustParse(puzzleTemplate)
	if err := tmpl.CreateFile(fileName, map[string]any{
		"Year": year,
		"Day":  FormatDay(day),
	}); err != nil {
		logrus.Fatal(err)
	}

	logrus.Infof("Created file: %s", fileName)
}

const initPkgTemplate = `// Code generated by aocgen; DO NOT EDIT.
	package year{{.Year}}

	import (
		"aocgen/pkg/aoc"
	)

	func Init() {
		aoc.Register({{.Year}}, map[int]aoc.Puzzle{
			{{.Puzzles}}
		})
	}
`

// Scan directory and autoload all structs in package Init func
func InitializePackage(year int) {
	path := fmt.Sprintf("./pkg/year%d", year)
	fileName := fmt.Sprintf("%s/year%d.go", path, year)
	puzzles := ""

	newYearPkgDirectory(year)
	files, err := ioutil.ReadDir(path)
	if err != nil {
		logrus.Fatal(err)
	}

	for _, file := range files {
		if file.IsDir() {
			continue
		}
		puzzleName := strings.Split(file.Name(), ".")[0]
		if !validPuzzleFile.Match([]byte(puzzleName)) {
			continue
		}
		day, _ := strconv.Atoi(puzzleName[3:])
		puzzles += fmt.Sprintf("%d: %s{},\n", day, strings.Title(strings.ToLower(puzzleName)))
		logrus.Debugf("Found puzzle file for %d-%d", year, day)
	}

	tmpl := codegen.MustParse(initPkgTemplate)
	if err := tmpl.CreateFile(fileName, map[string]interface{}{
		"Year":    year,
		"Puzzles": puzzles,
	}); err != nil {
		logrus.Fatal(err)
	}

	logrus.Infof("Created init file for package: %s", fileName)
}

const initMainTemplate = `// Code generated by aocgen; DO NOT EDIT.
	package years

	import (
		{{.Imports}}
	)

	func RegisterYears() {
		{{.Inits}}
	}
`

// InitializeYearsPackage scans directory and autoload all structs in main to call all Init funcs
func InitializeYearsPackages() {
	path := "./pkg/"

	err := os.Remove(yearsFile)
	if err != nil {
		logrus.Fatal(err)
	}
	logrus.Infof("Deleted file: %s", yearsFile)

	var imports, inits string

	dirs, err := ioutil.ReadDir(path)
	if err != nil {
		logrus.Fatal(err)
	}

	for _, dir := range dirs {
		if !dir.IsDir() || len(dir.Name()) < 8 || dir.Name()[:4] != "year" {
			logrus.Infof("Skipping directory for package: %s", dir.Name())
			continue
		}
		year, _ := strconv.Atoi(dir.Name()[4:])
		logrus.Infof("Found directory to include in codegen: %d", year)

		imports += fmt.Sprintf("\"aocgen/pkg/year%d\"\n", year)
		inits += fmt.Sprintf("year%d.Init()\n", year)
	}

	tmpl := codegen.MustParse(initMainTemplate)
	if err := tmpl.CreateFile(yearsFile, map[string]interface{}{
		"Imports": imports,
		"Inits":   inits,
	}); err != nil {
		logrus.Fatal(err)
	}
}

const benchmarkingTemplate = `// Code generated by aocgen; DO NOT EDIT.
	package year{{.Year}}

	import (
		"testing"

		"aocgen/pkg/aoc"
	)

	{{.Benchmarks}}
`

func NewBenchmarks(year int) {
	path := fmt.Sprintf("./pkg/year%d", year)
	fileName := fmt.Sprintf("%s/year%d_test.go", path, year)

	benchmarks := ""

	files, err := ioutil.ReadDir(path)
	if err != nil {
		logrus.Fatal(err)
	}

	for _, file := range files {
		if file.IsDir() {
			continue
		}
		puzzleName := strings.Split(file.Name(), ".")[0]
		if !validPuzzleFile.Match([]byte(puzzleName)) {
			continue
		}
		day, _ := strconv.Atoi(puzzleName[3:])
		benchmarks += fmt.Sprintf(`func Benchmark%dDay%s(b *testing.B) {
			Init()
			input := aoc.TestInput(%d, %d)
				p := aoc.NewPuzzle(%d, %d)
				b.Run("PartA", func(b *testing.B) {
					b.ResetTimer()
					for i := 0; i < b.N; i++ {
						p.PartA(input)
					}
				})
				b.Run("PartB", func(b *testing.B) {
					b.ResetTimer()
					for i := 0; i < b.N; i++ {
						p.PartB(input)
					}
				})
		}
		`, year, FormatDay(day), year, day, year, day)
	}

	tmpl := codegen.MustParse(benchmarkingTemplate)
	if err := tmpl.CreateFile(fileName, map[string]interface{}{
		"Year":       year,
		"Benchmarks": benchmarks,
	}); err != nil {
		logrus.Fatal(err)
	}

	logrus.Infof("Created file: %s", fileName)
}

func RemovePuzzle(year, day int) {
	fileName := puzzleFileName(year, day)
	err := os.Remove(fileName)
	if err != nil {
		logrus.Error(err)
		return
	}
	logrus.Info(fmt.Sprintf("File deleted: %s", fileName))

	InitializeYearsPackages()
	InitializePackage(year)
	NewBenchmarks(year)
}

func RemovePuzzleInput(year, day int) {
	fileName := puzzleInputFileName(year, day)
	err := os.Remove(fileName)
	if err != nil {
		logrus.Error(err)
		return
	}
	logrus.Info(fmt.Sprintf("File deleted: %s", fileName))

	InitializeYearsPackages()
	InitializePackage(year)
	NewBenchmarks(year)
}

// FormatDay zero pads single-digit days
func FormatDay(year int) string {
	yearStr := strconv.Itoa(year)
	if len(yearStr) == 1 {
		return "0" + yearStr
	}
	return yearStr
}
